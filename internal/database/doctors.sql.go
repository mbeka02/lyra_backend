// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: doctors.sql

package database

import (
	"context"
)

const createDoctor = `-- name: CreateDoctor :one
INSERT INTO doctors(user_id,specialization,license_number,description , years_of_experience , county , price_per_hour) VALUES ($1,$2,$3,$4,$5,$6,$7)RETURNING doctor_id, user_id, description, specialization, years_of_experience, county, price_per_hour, license_number, created_at, updated_at
`

type CreateDoctorParams struct {
	UserID            int64  `json:"user_id"`
	Specialization    string `json:"specialization"`
	LicenseNumber     string `json:"license_number"`
	Description       string `json:"description"`
	YearsOfExperience int32  `json:"years_of_experience"`
	County            string `json:"county"`
	PricePerHour      string `json:"price_per_hour"`
}

func (q *Queries) CreateDoctor(ctx context.Context, arg CreateDoctorParams) (Doctor, error) {
	row := q.db.QueryRowContext(ctx, createDoctor,
		arg.UserID,
		arg.Specialization,
		arg.LicenseNumber,
		arg.Description,
		arg.YearsOfExperience,
		arg.County,
		arg.PricePerHour,
	)
	var i Doctor
	err := row.Scan(
		&i.DoctorID,
		&i.UserID,
		&i.Description,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.County,
		&i.PricePerHour,
		&i.LicenseNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDoctors = `-- name: GetDoctors :many
SELECT 
    users.full_name, 
    doctors.specialization, 
    doctors.doctor_id, 
    users.profile_image_url, 
    doctors.description, 
    doctors.county, 
    doctors.price_per_hour, 
    doctors.years_of_experience
FROM doctors
INNER JOIN users ON doctors.user_id = users.user_id
WHERE 
    (NULLIF($1::text, '') IS NULL OR doctors.county ILIKE $1::text) -- County filter
ORDER BY 
    CASE 
        WHEN $2::text = 'price' AND $3::text = 'asc' THEN doctors.price_per_hour  
        WHEN $2::text = 'price' AND $3::text = 'desc' THEN doctors.price_per_hour * -1
        WHEN $2::text = 'experience' AND $3::text = 'asc' THEN doctors.years_of_experience
        WHEN $2::text = 'experience' AND $3::text = 'desc' THEN doctors.years_of_experience * -1
    END
LIMIT $5::int OFFSET $4::int
`

type GetDoctorsParams struct {
	SetCounty    string `json:"set_county"`
	SetSortBy    string `json:"set_sort_by"`
	SetSortOrder string `json:"set_sort_order"`
	SetOffset    int32  `json:"set_offset"`
	SetLimit     int32  `json:"set_limit"`
}

type GetDoctorsRow struct {
	FullName          string `json:"full_name"`
	Specialization    string `json:"specialization"`
	DoctorID          int64  `json:"doctor_id"`
	ProfileImageUrl   string `json:"profile_image_url"`
	Description       string `json:"description"`
	County            string `json:"county"`
	PricePerHour      string `json:"price_per_hour"`
	YearsOfExperience int32  `json:"years_of_experience"`
}

// FIXME:get this to return all results when county is an empty string or null
func (q *Queries) GetDoctors(ctx context.Context, arg GetDoctorsParams) ([]GetDoctorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDoctors,
		arg.SetCounty,
		arg.SetSortBy,
		arg.SetSortOrder,
		arg.SetOffset,
		arg.SetLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDoctorsRow
	for rows.Next() {
		var i GetDoctorsRow
		if err := rows.Scan(
			&i.FullName,
			&i.Specialization,
			&i.DoctorID,
			&i.ProfileImageUrl,
			&i.Description,
			&i.County,
			&i.PricePerHour,
			&i.YearsOfExperience,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
